package fr.gpmsi.da

import java.sql.PreparedStatement
import java.sql.ResultSet

/**
 * Classe de base pour une définition de colonne (classe abstraite), 
 * Ancêtre de toutes les colonnes typées
 */
abstract class ColumnDef {
    private String _name
    private Dao owner
    private boolean autogenerated = false
    
    /**
     * Retourner le nom de la colonne qui a été déclarée avec ce type
     * @return Le nom de la colonne
     */
    String getName() { return _name }
    /**
     * Définir le nom de la colonne pour cette définition
     * @param name_p Le nom de la colonne
     */
    void setName(String name_p) { this._name = name_p }
    
    /**
     * Retourner le propriétaire de cette colonne (habituellement une table)
     * @return L'objet propriétaire (un Dao)
     */
    Dao getOwner() { return owner }
    
    /**
     * Définir le propriétaire de cette colonne
     * @param owner l'objet Dao propriétaire
     */
    void setOwner(Dao owner) { this.owner = owner }
    
    /**
     * Retourner la longueur maximum de la colonne lorsque cela a lieu d'être.
     * Par défaut retourne 0
     * @return la longueur maximum
     */
    int getMaxLength() { return 0 }
    
    /** 
     * La valeur de cette colonne est-elle autogénérée lorsque la valeur null est
     * donnée à insérer ?
     * @return true si la valeur est autogénérée pour null
     */
    boolean isAutogenerated() { return autogenerated }
    /**
     * Définir l'autogénération de la valeur de colonne lorsque null est insérée
     * @param v true si une valeur est générée automatiquement
     * @return la définition de colonne
     */
    ColumnDef setAutogenerated(boolean v) { this.autogenerated = v ; return this }
    
     /**
      * Faire une valeur correctement typée, qui peut être insérée dans la base
      * de données, à partir de la String passée.
      * Les chaînes vides (longueur 0) sont converties en null.
      * Si la longueur maximum est dépassée, et que les préférences ne contiennent
      * par cutWhenOverflow, une exception est lancée.
      * @param str La chaîne à convertir
      * @param prefs Les préférences
      * @return L'objet du bon type
      * @throws MaximumSizeExceededException Si la taille maximum a été dépassée
      */
    abstract Object stringToValue(String str, DaPreferences prefs) 
        throws MaximumSizeExceededException
        
    /**
     * Faire une String à partir de la valeur donnée (qui est normalement
     * lue depuis la base de données). Les valeurs null sont converties
     * en chaîne vide "".
     * @param val La valeur à transformer en String
     * @param prefs Les préférences
     * @return La String résultante
     */
    abstract String valueToString(Object val, DaPreferences prefs)
    
    /**
     * Définir la valeur dans le PreparedStatement (y compris avec le bon type pour setNull)
     * @param ps
     * @param index
     * @param val
     */
    abstract void setPsValue(PreparedStatement ps, int index, Object val)
    
    /**
     * Lire la valeur depuis le ResultSet
     * @param rs Le ResultSet
     * @param index L'index à partir duquel lire la valeur (commence à 0)
     * @return La valeur lue
     */
    abstract Object getRsValue(ResultSet rs, int index)
    
    /**
     * Retourner une instruction de déclaration de cette colonne, pour le dialecte considéré
     * @param dialect Le nom du dialecte, pour l'instant seul H2 est supporté
     * @return l'instruction pour créer la colonne, par ex. "prenom VARCHAR (32)"
     */
    abstract String getDdl(String dialect)
    
}

