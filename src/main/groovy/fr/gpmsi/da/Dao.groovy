package fr.gpmsi.da

import groovy.sql.Sql
import java.text.NumberFormat
import java.text.SimpleDateFormat

import fr.gpmsi.StringUtils

/**
 * Classe pour un DAO (Data Access object) qui sert d'intermédiaire entre une base de données
 * et des classes Groovy.
 * A noter que Groovy facilite beaucoup l'accès aux bases de données, et un système à base de Dao est
 * moins utile que pour, par exemple, java.
 * L'utilisation d'objets Dao évite le recours à Hibernate (<a href="https://hibernate.org/">https://hibernate.org/</a>),
 * qui est assez lourd en manipulation. Mais Hibernate est plus adapté à partir de quelques dizaines de tables.
 */
class Dao {
    def columnsByName = [:]
    def columnIndexesByName = [:]
    List<ColumnDef> columns = [] //toutes les colonnes, y compris les clés primaires
    List<ColumnDef> pk = [] //les clés primaires. Si vide -> pas de clé primaire. Si plus de 1 -> clé primaire composite
    def tableName = "?"
    
    /**
     * Constructeur avec nom de la table
     * @param tableName Le nom de la table que ce DAO reflète
     */
    Dao(String tableName) { this.tableName = tableName }
    
    /** Retourner le nom de la table */
    def getTableName() { tableName } 
    
    /** Déclarer une colonne à partir de sa définition */
    def col(ColumnDef cd) { 
        columnsByName.put(cd.getName(), cd)
        cd.owner = this
        // println("for col '${dt.getName()}' putting index ${columns.size}")
        columnIndexesByName[cd.getName()] = columns.size 
        columns.add(cd)
    }
    
    /** déclarer une colonne comme partie de la clé primaire */
    def pkcol(ColumnDef cd) { col(cd); pk << cd }
    
    /**
     * Retourner tous les noms de colonnes
     * @return Une liste des noms de colonne
     */
    def getAllColNames() { columns.collect { e -> e.name } }
    
    /**
     * Retourner les noms de colonne qui font partie de la clé primaire
     * @return Une liste des noms de colonne
     */
    def getAllPkColNames() { pk.collect { e -> e.name } }
    
    /**
     * Créer une liste de valeurs null, de la bonne taille (le nombre de colonnes)
     * @return La liste
     */
    def makeEmptyValueList() { return [null] * column.size }
    
    /**
     * Pour une liste de valeurs (rangées dans l'ordre des colonnes), retourner
     * la valeur qui correspond au nom de colonne
     * @param values Les valeurs
     * @param name Le nom de la colonne
     * @return La valeur à l'endroit de la colonne
     */
    def getValue(List values, String name) {
        int index = columnIndexesByName[name]
        return values.get(index)
    }

    /**
     * Dans la liste de valeurs (rangées dans l'ordre des colonnes),
     * définir l'élément qui correspond au nom de colonne. 
     * @param values La liste de valeurs
     * @param name Le nom de la colonne
     * @param value La valeur à mettre à l'endroit de la colonne
     * @return cet objet DAO
     */
    def setValue(List values, String name, value) {
        int index = columnIndexesByName[name]
        values.set(index, value)
        this
    }
    
    /**
     * Insert values in database.
     * Also handles autogenerated values by not inserting them if they are null.
     * In the passed values array, sets the generated keys if they were autogenerated
     */
    def insertInDb(Sql gsql, values) {
        def qms = ""
        def debugInsert = false
        if (debugInsert) { values.eachWithIndex {v,i-> println "$i:'$v'" } }
        def tn = getTableName()
        def colsToInsert = []
        def colNamesToInsert = []
        def valsToInsert = []
        columns.eachWithIndex {col, index ->
            if (col.autogenerated && values[index] == null) {
                //ignore this column
            }
            else {
                colsToInsert << col
                colNamesToInsert << col.name
                valsToInsert << values[index]
            }
        }
        if (valsToInsert.size > 0) qms = (",?" * valsToInsert.size)[1..-1]
        def allInsCols = colNamesToInsert.join(',')
        def insertSql = "INSERT INTO $tn($allInsCols) VALUES ($qms)" as String
        println("Insert sql : $insertSql , Vals to insert : $valsToInsert")
		def generatedValues = gsql.executeInsert insertSql, valsToInsert
		//now use the returned list of rows to set the values that were generated
		def j = 0
		columns.eachWithIndex {col, index ->
            if (col.autogenerated && values[index] == null) {
                values[index] = generatedValues[0][j] 
                j++
            }
        }
	}

	/** constructs a where clause and fills the values for the placeholders 
	 * This method does not handle values
	 */
	def makePkWhereClause() {
		def wheres = ""
		def allPkCols = getAllPkColNames()
		allPkCols.eachWithIndex {col, index ->
			if (index > 0) wheres += ' AND '
			wheres += col
			wheres += '=?'
		}
		return wheres
	}
	
	/**
	 * Update this object row
	 * Returns nr. of updated rows (normally 1)
	 */
	def updateToDb(Sql gsql, values) {
	    def allCols = getAllColNames()
	    def allVals = []
		def sets = ""
		allCols.eachWithIndex {col, index ->
			if (index > 0) sets += ','
			sets += col.name
			sets += '=?'
			allVals << values[index]
		}
		def wheres = ""
		def allPkCols = getAllPkColNames()
		allPkCols.eachWithIndex {col, index ->
			if (index > 0) wheres += ' AND '
			wheres += col
			wheres += '=?'
			allVals << getValue(values, col) //add value for this pk column
		}
		def tn = getTableName()
		def updateSql = "UPDATE $tn SET $sets WHERE $wheres" as String
		def nrowsu = gsql.executeUpdate updateSql, allVals
		return nrowsu
	}

	/** Renvoie la colonne qui est à l'index donné (commence à 0) */
	ColumnDef getColumn(int index) { return columns[index] }
	
	/**
	 * Renvoie la colonne dont le nom est donné dans name.
	 * Renvoie null si la colonne n'existe pas.
	 */
	ColumnDef getColumn(String cname) { return columnsByName[cname] }
	
	/**
	 * Renvoie le nombre de colonnes déclarées
	 */
	int getColumnCount() { columns.size() }
	
	/**
	 * Retourne le numéro de la colonne. Attention ici les numéros commencent
	 * à 0
	 */
	int getColumnIndex(String cname) {
	    Integer ix = columnIndexesByName[cname]
	    // println("For column '$cname' got index $ix")
	    return (ix == null) ? -1 : ix //return ix or -1 if null
	}

	List<ColumnDef> getColumns(String[] colNames) {
	    def cols = []
	    colNames.each {colName ->
	        def col = getColumn(colName)
	        if (col == null) throw new Exception("Column not found '$colName'")
	        else cols << col
	    }
	    return cols
	}
	
	/**
	 * Teste si la rangée existe dans la base de données, en utilisant les clés
	 * primaires.
	 * @return true si c'est le cas
	 */
	boolean rowExists(Sql gsql, List keyValues) {
	    def tn = getTableName()
	    def wheres = makePkWhereClause()
	    def selectSql = "SELECT count(*) rowcount FROM $tn WHERE $wheres"
	    def row = gsql.firstRow selectSql, keyValues
	    return row.rowcount > 0
	}
	
	/**
	 * Produit des valeurs correctes à partir des chaînes de caractère passées
	 * en paramètre, la liste doit être dans l'ordre de déclaration des colonnes
	 */
	List makeValuesFromStrings(List<String> strVals, DaPreferences prefs) {
	    def results = []
	    def sz = strVals.size()
	    for (int i = 0; i < sz; i++) {
	        def col = columns[i]
	        println ("col '${col.name}'")
	        def val = col.stringToValue(strVals[i], prefs)
	        println("val:$val")
	        results << val
	    }
	    return results;
	}
	
	/**
	 * Lit les valeurs depuis la base de données.
	 * Les clés doivent avoir été mises au bon endroit dans le tableau.
	 * Met à jour le tableau passé en paramètre, et renvoie aussi ce tableau.
	 */
	def readFromDb(Sql gsql, values) {
	    def tn = getTableName()
	    def wheres = makePkWhereClause()
	    def allCols = getAllColNames().join(',')
	    def keyValues = []
	    pk.each {k -> keyValues << values[columnIndexesByName[k.name]] }
	    def selectSql = "SELECT $allCols rowcount FROM $tn WHERE $wheres"
	    def row = gsql.firstRow selectSql, keyValues
	    def rowSize = row.size()
	    for (int i = 0; i < rowSize; i++) { values[i] = row.getAt(i) }
	    return values
	}
	
    /**
     * Crée une nouvelle rangée de Dao
     * @return Un nouvel objet DaoRow, avec ce Dao en parent
     */
	def makeNewDaRow() { return new DaRow(this) }
	
  /**
   * Créer une instruction DDL pour définir cette table dans la base.
   * @param extraSql le SQL à rajouter à la fin. Doit contenir la virgule initiale qui sépare cette instruction de celles qui le précèdent.
   * @param dialect Le nom du dialecte à utiliser. Seul "H2" est supporté pour l'instant.
   * @return L'instruction DDL de création de la table.
   */
    String makeTableDdl(String extraSql, String dialect) {
      if (!dialect.equalsIgnoreCase("H2")) return "dialecte non supporté : $dialect"
      String nl = System.lineSeparator()
      StringBuilder sb = new StringBuilder()
      sb << "CREATE TABLE $tableName ("
      boolean first = true
      //on commence par déclarer la ou les clés primaires
      if (pk.size() == 1) {
        sb << nl
        //cle primaire composee d'une seule colonne
        sb << pk[0].getDdl(dialect) << " PRIMARY KEY"
        first = false
      }
      //ensuite on déclare chaque colonne
      columns.each {c ->
        if (pk.contains(c) && pk.size() == 1) return; //si c'est une clé primaire unique, elle a déjà été déclarée
        if (first) first = false
        else sb << ","
        sb << nl
        sb << c.getDdl(dialect)         
      }
      //puis si la clé primaire est composée de plusieurs colonnes, on les ajoute
      if (pk.size() > 1) {
        if (first) first = false
        else sb << ","
        sb << nl
        //cle multiple, declarer cette contrainte à la fin
        def pkNames = pk*.name
        sb << "PRIMARY KEY(${pkNames.join(',')})"
      }
      //enfin on ajoute le SQL supplémentaire si nécessaire
      if (extraSql != null) {
        sb << extraSql
        first = false
      }
      if (first) first = false
      else sb << nl
      sb << ")"
      return sb.toString();
    
    } 
}