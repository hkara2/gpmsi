package fr.karadimas.gpmsi.da

import groovy.sql.Sql
import java.text.NumberFormat
import java.text.SimpleDateFormat

/**
 * Base Data Access object
 */
abstract class Dao {
    def columnsByName = [:]
    def columnIndexesByName = [:]
    def columns = []
    def pk = [] //primary key. If empty -> no primary key. If more than 1 element -> composite primary key
    def tableName = "?"
    
    Dao(String tableName) { this.tableName = tableName }
    
    /** You can override this method */
    def getTableName() { tableName } 
    
    /** declare a column */
    def col(ColumnDef dt) { 
        columnsByName.put(dt.getName(), dt)
        dt.owner = this
        // println("for col '${dt.getName()}' putting index ${columns.size}")
        columnIndexesByName[dt.getName()] = columns.size 
        columns.add(dt)
    }
    
    /** declare a column as part of the primary key */
    def pkcol(ColumnDef dt) { col(dt); pk << dt }
    
    def getAllColNames() { columns.collect { e -> e.name } }
    
    def getAllPkColNames() { pk.collect { e -> e.name } }
    
    /** Make an empty value list, of the correct size, with all nulls */
    def makeEmptyValueList() { return [null] * column.size }
    
    /**
     * For a list of values that is ordered identically to 'columns', get the
     * value that corresponds to the column name
     */
    def getValue(List values, String name) {
        int index = columnIndexesByName[name]
        return values.get(index)
    }

    def setValue(List values, String name, value) {
        int index = columnIndexesByName[name]
        values.set(index, value)
    }
    
    /**
     * Insert values in database.
     * Also handles autogenerated values by not inserting them if they are null.
     * In the passed values array, sets the generated keys if they were autogenerated
     */
    def insertInDb(Sql gsql, values) {
        def qms = ""
        def debugInsert = false
        if (debugInsert) { values.eachWithIndex {v,i-> println "$i:'$v'" } }
        def tn = getTableName()
        def colsToInsert = []
        def colNamesToInsert = []
        def valsToInsert = []
        columns.eachWithIndex {col, index ->
            if (col.autogenerated && values[index] == null) {
                //ignore this column
            }
            else {
                colsToInsert << col
                colNamesToInsert << col.name
                valsToInsert << values[index]
            }
        }
        if (valsToInsert.size > 0) qms = (",?" * valsToInsert.size)[1..-1]
        def allInsCols = colNamesToInsert.join(',')
        def insertSql = "INSERT INTO $tn($allInsCols) VALUES ($qms)" as String
        println("Insert sql : $insertSql , Vals to insert : $valsToInsert")
		def generatedValues = gsql.executeInsert insertSql, valsToInsert
		//now use the returned list of rows to set the values that were generated
		def j = 0
		columns.eachWithIndex {col, index ->
            if (col.autogenerated && values[index] == null) {
                values[index] = generatedValues[0][j] 
                j++
            }
        }
	}

	/** constructs a where clause and fills the values for the placeholders 
	 * This method does not handle values
	 */
	def makePkWhereClause() {
		def wheres = ""
		def allPkCols = getAllPkColNames()
		allPkCols.eachWithIndex {col, index ->
			if (index > 0) wheres += ' AND '
			wheres += col
			wheres += '=?'
		}
		return wheres
	}
	
	/**
	 * Update this object row
	 * Returns nr. of updated rows (normally 1)
	 */
	def updateToDb(Sql gsql, values) {
	    def allCols = getAllColNames()
	    def allVals = []
		def sets = ""
		allCols.eachWithIndex {col, index ->
			if (index > 0) sets += ','
			sets += col.name
			sets += '=?'
			allVals << values[index]
		}
		def wheres = ""
		def allPkCols = getAllPkColNames()
		allPkCols.eachWithIndex {col, index ->
			if (index > 0) wheres += ' AND '
			wheres += col
			wheres += '=?'
			allVals << getValue(values, col) //add value for this pk column
		}
		def tn = getTableName()
		def updateSql = "UPDATE $tn SET $sets WHERE $wheres" as String
		def nrowsu = gsql.executeUpdate updateSql, allVals
		return nrowsu
	}

	/** Renvoie la colonne qui est � l'index donn� (commence � 0) */
	ColumnDef getColumn(int index) { return columns[index] }
	
	/**
	 * Renvoie la colonne dont le nom est donn� dans name.
	 * Renvoie null si la colonne n'existe pas.
	 */
	ColumnDef getColumn(String cname) { return columnsByName[cname] }
	
	/**
	 * Renvoie le nombre de colonnes d�clar�es
	 */
	int getColumnCount() { columns.size() }
	
	/**
	 * Retourne le num�ro de la colonne. Attention ici les num�ros commencent
	 * � 0
	 */
	int getColumnIndex(String cname) {
	    Integer ix = columnIndexesByName[cname]
	    // println("For column '$cname' got index $ix")
	    return (ix == null) ? -1 : ix //return ix or -1 if null
	}

	List<ColumnDef> getColumns(String[] colNames) {
	    def cols = []
	    colNames.each {colName ->
	        def col = getColumn(colName)
	        if (col == null) throw new Exception("Column not found '$colName'")
	        else cols << col
	    }
	    return cols
	}
	
	/**
	 * Teste si la rang�e existe dans la base de donn�es, en utilisant les cl�s
	 * primaires.
	 * @return true si c'est le cas
	 */
	boolean rowExists(Sql gsql, List keyValues) {
	    def tn = getTableName()
	    def wheres = makePkWhereClause()
	    def selectSql = "SELECT count(*) rowcount FROM $tn WHERE $wheres"
	    def row = gsql.firstRow selectSql, keyValues
	    return row.rowcount > 0
	}
	
	/**
	 * Produit des valeurs correctes � partir des cha�nes de caract�re pass�es
	 * en param�tre, la liste doit �tre dans l'ordre de d�claration des colonnes
	 */
	List makeValuesFromStrings(List<String> strVals, DaPreferences prefs) {
	    def results = []
	    def sz = strVals.size()
	    for (int i = 0; i < sz; i++) {
	        def col = columns[i]
	        println ("col '${col.name}'")
	        def val = col.stringToValue(strVals[i], prefs)
	        println("val:$val")
	        results << val
	    }
	    return results;
	}
	
	/**
	 * Lit les valeurs depuis la base de donn�es.
	 * Les cl�s doivent avoir �t� mises au bon endroit dans le tableau.
	 * Met � jour le tableau pass� en param�tre, et renvoie aussi ce tableau.
	 */
	def readFromDb(Sql gsql, values) {
	    def tn = getTableName()
	    def wheres = makePkWhereClause()
	    def allCols = getAllColNames().join(',')
	    def keyValues = []
	    pk.each {k -> keyValues << values[columnIndexesByName[k.name]] }
	    def selectSql = "SELECT $allCols rowcount FROM $tn WHERE $wheres"
	    def row = gsql.firstRow selectSql, keyValues
	    def rowSize = row.size()
	    for (int i = 0; i < rowSize; i++) { values[i] = row.getAt(i) }
	    return values
	}
	
	def makeNewDaRow() { return new DaRow(this) }
	
}